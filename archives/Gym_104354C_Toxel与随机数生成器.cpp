// INFO: Tags : -
//        URL : https://vjudge.net/problem/Gym-104354C
//
// 题目背景：知名游戏公司 KaerfEmag 在其最新游戏 Telracs & Teloiv 中生成随机数的算法有很大的漏洞，
// 生成的序列 “不够随机”，严重影响玩家的游戏体验。作为 KaerfEmag 公司的项目负责人，Toxel需要修复这一漏洞。
// 这里有一个简单的随机数生成器 XorShift64：
// -----
// uint64_t rng = seed; // uint64_t 一 般 可 认 为 是 unsigned long long
// uint64_t XorShift64(){
//   rng ^= rng << 13;
//   rng ^= rng >> 7;
//   rng ^= rng << 17;
//   return rng;
// }
// -----
// 只要提供初始种子 seed，不断调用 XorShift64 函数，就可以产生随机的 0/1 序列：
// -----
// 算法 1 正确的随机序列生成器
// 1: rng ← seed
// 2: for i ← 1 to 106 do
// 3:   randomBit ← XorShift64() mod 2
// 4:   Print(randomBit)
// 5: end for
// -----
// 不幸的是，Telracs & Teloiv 代码中的随机序列生成器是不正确的：
// -----
// 算法 2 错误的随机序列生成器
// 1: lengthList ← [length1, length2, . . . , lengthm]
// 2: for each length ∈ lengthList do
// 3:   rng ← seed                                        ▷ 错误地将 rng 重置为了初始种子 seed
// 4:   for i ← 1 to length do
// 5:     randomBit ← XorShift64() mod 2
// 6:     Print(randomBit)
// 7:   end for
// 8: end for
// -----
// 这会导致序列随机性不够强，每隔 length_i 个位置，序列就会开始重复。
// 现给出一段 0/1 序列，请你判断生成它的随机序列生成器是正确的还是错误的。
//
// 输入格式
// 一行一个字符串 s（|s| = 10^6），仅包含字符 0 或 1，保证该字符串由题目所描述的两种随机序列生成器之一生成。
// 保证 10^3 ≤ length_i ≤ 10^4 且Σ_(i=1)^m length_i = 10^6。
// **但是，样例受篇幅所限，不满足前述数据范围。样例不会出现在实际测试数据中。**
//
// 输出格式
// 输出一行一个字符串。如果生成输入字符串的是正确的随机序列生成器，则输出 Yes，否则输出 No（大小写不敏感）。
//
// HACK: 官方题解
// 由于本题具有随机性，很多算法都可能通过。
// 一种做法是，注意到错误代码的结果中一定会出现非常长的子串（长度至少为10^3）与字符串的前缀相同。
// 这由字符串的生成方式可以很容易发现。而正确代码产生的字符串完全随机，出现这种情况的概率仅略高于 2^−1000，可以认为不可能发生。
// __为找出这样的子串，可以想到 KMP 算法，其所求得的 fail 数组正是我们需要的。__
// __如果 fail 数组的最大值高于 50，就已有极大把握认为是错误代码的结果了。__
// 直接暴力 find 也行 :)
// 时间复杂度 O(|s|)。
//
// INFO: Memory : ~100 kB
//         Time : ~200 ms

// Sample Input
// 2
// 000101110010010000111000100000010001000001101111001010010110000101110010010000111000100000010001000001101111001010010110000101110010010000111000100000010001000001101111001010010110000101110010010000111000100000010001000001101111001010010110000101110010010000111000100000010001000001101111001010010110
// 000101110010010000111000100000010001000001101111001010010110000101001011011010111011100010101101110111000101101011010000010001110000000010111010101010011001110010011011010101111001001100100100100110001011101000101100010111100110100011000010001101011001111101011010000110101010010000000111010101110110

// Sample Output
// No
// Yes

#include <iostream>
using namespace std;

void solve() {
  string s;
  cin >> s;
  string p = s.substr(0, 1000);
  if (s.find(p, 1001) != string::npos) {
    cout << "No" << endl;
  } else {
    cout << "Yes" << endl;
  }
}

int main() {
#ifdef LOCAL_JUDGE
  int T;
  cin >> T;
  while (T--)
#endif
    solve();
  return 0;
}
