// INFO: Tags : 模拟 字符画
//        URL : https://vjudge.net/problem/Gym-104354G
//
// 一天，Toxel 找到了一个形如 x^y 的数学表达式，其中 x 和 y 都是正整数。
// 他希望以 “自我包含” 的方式将这个表达式绘制成字符画。
// 具体来说，Toxel 首先将计算出 x^y 的结果等于 z。若 z ≤ 10^18，Toxel 将把 x^y = z 绘制出来；否则，他将绘制 x^y = INF。
// Toxel 将在一个 10 × m 像素的画布上绘制表达式。
// 非指数部分的数字，以及 =INF 这四个符号每个占据 7 × 7 像素的位置，且其顶端与画布顶端距离为 2。
// 指数部分的数字每个占据 5 × 5像素的位置，且其顶端与画布顶端距离为 1。
// 每个数字或符号所包含的像素均填入本字符，其余空白像素则填入 . 字符。
// 数字和符号的具体形态请参见末尾的提示部分。任意两个符号之间应间隔恰好一列空白像素，且左右两端也应留出恰一列空白像素。
// 需要注意的是，字符 1 也需要占满 7 × 7（非上标）或 5 × 5（上标）像素。请参阅样例以更好地理解题意。
// Toxel 最近忙于给河南省赛命题，因此没有时间自己来绘制字符画了。请你帮他完成这个任务。
//
// 输入格式
// **本题包含多组数据。**
// 第一行包含一个整数 T（1 ≤ T ≤ 100），表示数据组数。
// 对于每组数据：
// 一行包含一个字符串，格式为 x^{y}。其中 x, y 为正整数，且满足 1 ≤ x, y ≤ 10^18。字符串中不包含任何其它字符。
//
// 输出格式
// 对于每组数据：
// 首先输出 10 行 10 个字符串，表示字符画。
// 再输出一行空白行，以便分割各组数据。

// Sample Input
// 6
// 47^{2}
// 47^{0}
// 56^{2}
// 1^{1}
// 80^{1}
// 233^{233}

// Sample Output
// ...............................................................
// .................22222.........................................
// .4.....4.7777777.....2.........2222222.2222222.0000000.9999999.
// .4.....4.......7.22222...............2.......2.0.....0.9.....9.
// .4.....4.......7.2.....=======.......2.......2.0.....0.9.....9.
// .4444444.......7.22222.........2222222.2222222.0.....0.9999999.
// .......4.......7.......=======.2.......2.......0.....0.......9.
// .......4.......7...............2.......2.......0.....0.......9.
// .......4.......7...............2222222.2222222.0000000.9999999.
// ...............................................................
//
// .......................................
// .................00000.................
// .4.....4.7777777.0...0...............1.
// .4.....4.......7.0...0...............1.
// .4.....4.......7.0...0.=======.......1.
// .4444444.......7.00000...............1.
// .......4.......7.......=======.......1.
// .......4.......7.....................1.
// .......4.......7.....................1.
// .......................................
//
// ...............................................................
// .................22222.........................................
// .5555555.6666666.....2.........3333333.......1.3333333.6666666.
// .5.......6.......22222...............3.......1.......3.6.......
// .5.......6.......2.....=======.......3.......1.......3.6.......
// .5555555.6666666.22222.........3333333.......1.3333333.6666666.
// .......5.6.....6.......=======.......3.......1.......3.6.....6.
// .......5.6.....6.....................3.......1.......3.6.....6.
// .5555555.6666666...............3333333.......1.3333333.6666666.
// ...............................................................
//
// ...............................
// .............1.................
// .......1.....1...............1.
// .......1.....1...............1.
// .......1.....1.=======.......1.
// .......1.....1...............1.
// .......1.......=======.......1.
// .......1.....................1.
// .......1.....................1.
// ...............................
//
// ...............................................
// .....................1.........................
// .8888888.0000000.....1.........8888888.0000000.
// .8.....8.0.....0.....1.........8.....8.0.....0.
// .8.....8.0.....0.....1.=======.8.....8.0.....0.
// .8888888.0.....0.....1.........8888888.0.....0.
// .8.....8.0.....0.......=======.8.....8.0.....0.
// .8.....8.0.....0...............8.....8.0.....0.
// .8888888.0000000...............8888888.0000000.
// ...............................................
//
// ...........................................................................
// .........................22222.33333.33333.................................
// .2222222.3333333.3333333.....2.....3.....3.........IIIIIII.N.....N.FFFFFFF.
// .......2.......3.......3.22222.33333.33333............I....NN....N.F.......
// .......2.......3.......3.2.........3.....3.=======....I....N.N...N.F.......
// .2222222.3333333.3333333.22222.33333.33333............I....N..N..N.FFFFFFF.
// .2.............3.......3...................=======....I....N...N.N.F.......
// .2.............3.......3..............................I....N....NN.F.......
// .2222222.3333333.3333333...........................IIIIIII.N.....N.F.......
// ...........................................................................
//
// HACK: 官方题解
// 按照题意模拟即可。
//
// INFO: Memory : ~100 kB
//         Time : <100 ms

#include <cmath>
#include <iostream>
#include <vector>
using namespace std;

// clang-format off
vector<string> bigmap = {
  "................................................................................",
  "................................................................................",
  "0000000.......1.2222222.3333333.4.....4.5555555.6666666.7777777.8888888.9999999.",
  "0.....0.......1.......2.......3.4.....4.5.......6.............7.8.....8.9.....9.",
  "0.....0.......1.......2.......3.4.....4.5.......6.............7.8.....8.9.....9.",
  "0.....0.......1.2222222.3333333.4444444.5555555.6666666.......7.8888888.9999999.",
  "0.....0.......1.2.............3.......4.......5.6.....6.......7.8.....8.......9.",
  "0.....0.......1.2.............3.......4.......5.6.....6.......7.8.....8.......9.",
  "0000000.......1.2222222.3333333.......4.5555555.6666666.......7.8888888.9999999.",
  "................................................................................",
};

vector<string> uppermap = {
  "............................................................",
  "00000.....1.22222.33333.4...4.55555.66666.77777.88888.99999.",
  "0...0.....1.....2.....3.4...4.5.....6.........7.8...8.9...9.",
  "0...0.....1.22222.33333.44444.55555.66666.....7.88888.99999.",
  "0...0.....1.2.........3.....4.....5.6...6.....7.8...8.....9.",
  "00000.....1.22222.33333.....4.55555.66666.....7.88888.99999.",
  "............................................................",
  "............................................................",
  "............................................................",
  "............................................................",
};

vector<string> equalmap = {
  "........",
  "........",
  "........",
  "........",
  "=======.",
  "........",
  "=======.",
  "........",
  "........",
  "........",
};

vector<string> infmap = {
  "........................",
  "........................",
  "IIIIIII.N.....N.FFFFFFF.",
  "...I....NN....N.F.......",
  "...I....N.N...N.F.......",
  "...I....N..N..N.FFFFFFF.",
  "...I....N...N.N.F.......",
  "...I....N....NN.F.......",
  "IIIIIII.N.....N.F.......",
  "........................",
};
// clang-format on

using ull = unsigned long long;

ull x, y;

void draw(ull ans) {
  int N = 10;
  vector<string> canvas(N, "");

  for (char c : to_string(x)) {
    int d = c - '0';
    for (int i = 0; i < N; i++) {
      canvas[i] += bigmap[i].substr(d * 8, 8);
    }
  }

  for (char c : to_string(y)) {
    int d = c - '0';
    for (int i = 0; i < N; i++) {
      canvas[i] += uppermap[i].substr(d * 6, 6);
    }
  }

  for (int i = 0; i < N; i++) {
    canvas[i] += equalmap[i];
  }

  if (ans == -1ull) {
    for (int i = 0; i < N; i++) {
      canvas[i] += infmap[i];
    }
  } else {
    for (char c : to_string(ans)) {
      int d = c - '0';
      for (int i = 0; i < N; i++) {
        canvas[i] += bigmap[i].substr(d * 8, 8);
      }
    }
  }

  for (string &line : canvas) {
    cout << "." << line << endl;
  }
  cout << endl;
}

// NOTE: 快速幂（递归版）
// ull pow(ull x, ull y) {
//   if (y == 0)
//     return 1;
//   ull half = pow(x, y / 2);
//   if (y % 2 == 0)
//     return half * half;
//   else
//     return half * half * x;
// }

// NOTE: 快速幂（迭代版）
ull pow(ull x, ull y) {
  ull res = 1;
  while (y) {
    if (y & 1) // y % 2
      res *= x;
    x *= x;
    y >>= 1; // y /= 2
  }
  return res;
}

int main() {
  int T;
  cin >> T;
  while (T--) {
    char _;
    cin >> x >> _ >> _ >> y >> _;
    // NOTE: y*log10(x) > 18
    //       log10(x^y) > 18
    //              x^y > 10^18
    if (y * log10(x) > 18) {
      draw(-1ull);
      continue;
    }
    draw(pow(x, y));
  }
  return 0;
}
