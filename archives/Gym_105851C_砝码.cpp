// INFO: Tags : 贪心
//        URL : https://vjudge.net/problem/Gym-105851C
//
// Link 有 m 个砝码，每个砝码的重量都是一个正整数。
// 已知 Link 可以用这些砝码称出 1 到 n 中的所有整数重量（砝码仅能放在天平的同一边），
// Link 手上最重的砝码至少有多重？
// 注意：Link 手上的砝码能否表示出 n + 1 或更大的重量是未知的。
//
// 输入
// 每个测试文件包含多组测试数据。第一行包含测试数据的组数 T (1 ≤ T ≤ 2 × 10^5) 。
// 每组测试数据的格式如下。
// 第一行包含两个整数 n 和 m (1 ≤ n, m ≤ 10^9) ，表示砝码能表示的已知最大重量和砝码的数量。
//
// 输出
// 对于每组数据，输出一行一个整数，表示 Link 手上最重的砝码的重量的最小值。
// 如果不可能用 m个砝码表示出 1 到 n 中的所有重量，请输出 “-1” 。
//
// HACK: 官方题解
// （代码的解法不大一样，但本质是一样的）
// 假设答案为 x，首先要表示 1 到 x − 1，至少需要 k = ⌊log2(x)⌋ 个砝码。
// 这样可以用 1, 2, ..., 2^(k−1) 重量的砝码表示前 x−1 个重量。
// 于是我们枚举 k，此时最重能表示 2^(k−1)，剩下的重量需要用 m-k 个砝码表示，
// 因此 x = ⌈ ( n − ( 2^(k) − 1 ) ) / m−k ⌉。
// 这里的 x 还需要满足两个约束：
// • x ≥ 2^(k−1)，即需要超过前 k 个的值。
// • x ≤ 2^(k)，即 k ≥ log2(x)，否则 x − 1 无法表示。
//
// INFO: Memory : ~600 kB
//         Time : ~60 ms

// Sample Input
// 2
// 40 6
// 16 4

// Sample Output
// 13
// -1

#include <iostream>
using namespace std;

void solve() {
  int n, m;
  cin >> n >> m;

  // NOTE: 考虑前几个砝码都是 1 2 4 8 ... 2^(k-1), 这样可以表示前 2^k-1 的重量。
  // INFO: 注意，这种取法事实上是非常劣的，会导致最重砝码的最小值很大。但这种取法的 coverage 是最好的。
  int sum = 0;
  for (int i = 1;; i *= 2) {
    sum += i;
    m--;

    // NOTE: 如果一直按上面的方法加砝码，直到砝码用完
    if (m == 0) {
      // NOTE: 此时可以表示的数的最大值如果达到了 n，
      //       那么此时最重的砝码就是保证满足条件的最轻的情况，
      //       直接返回。
      if (sum >= n) {
        cout << i << endl;
        return;
      }

      // NOTE: 但如果砝码用完都达不到 n，就一定不行了，返回 -1
      else {
        cout << -1 << endl;
        return;
      }
    }

    // INFO: 而这种取法在结果上则是最优的，但 coverage 不行，只能最后用。
    // NOTE: 我们算一下如果前面的砝码按上面的方法取，
    //       每次取完后剩下的重量，如果把剩下的砝码都取同一个数 x（向上取整）
    //       如果 x 比下一步按上面的取法取砝码好要小，则 x 更优
    int x = (n - sum + m - 1) / m;
    if (x <= (i * 2)) {
      // NOTE: 返回的时候与当前砝码 i 比一下，取大的，确保可以表示出 n
      cout << max(x, i) << endl;
      return;
    }
  }
}

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  int T;
  cin >> T;
  while (T--)
    solve();
  return 0;
}
