// INFO: Tags : 单调队列 差分数组 区间最值
//        URL : https://vjudge.net/problem/Gym-104354F
//
// 给定一个长度为 n 的非负整数序列 A1, A2, . . . , An，其中 n ≥ 2。
// 给定正整数 k，满足 2 ≤ k ≤ n。要求从 A1, A2, ..., An 中选择 k 项 Ap1, Ap2, ..., Apk（1 ≤ p1 < p2 < · · · < pk ≤ n），使得下式取得最小值：
// min_(1≤i<j≤k){|Api − Apj|} * max_(1≤i<j≤k){|Api − Apj|}
// 试求上式能够取得的最小值。
//
// 输入格式
// 第一行包含两个正整数 n，k（2 ≤ k ≤ n ≤ 5 × 10^5），表示非负整数序列 A 的长度及选取的项数。
// 第二行包含 n 个非负整数 A1, ..., An（0 ≤ Ai ≤ 10^9），表示给定的序列 A。
//
// 输出格式
// 一行包含一个整数，表示答案。
//
// HACK: 官方题解
// 不妨记 A 升序排序后得到 A′。我们有以下结论（证明略，题解上有）：
// > 存在一种最优的选择方案，满足所选的项在 A′ 中是连续的。
// 将 A 排序后，枚举所选区间的端点，
// 单调队列维护区间中差分项的最小值即可得到 min 项，
// 区间左右端点值之差即为 max项，
// 取 min * max 最小的区间即可。
// 复杂度 O(n log n)
//
// INFO: Memory : ~4300 kB
//         Time : ~>800 ms

// Sample Input
// 6
// 13 7
// 1 1 4 5 1 4 1 9 1 9 8 1 0
// 4 2
// 114 514 1919 810
// 6 3
// 121 117 114 105 107 111
// 5 3
// 1 2 2 1000 2000
// 6 4
// 1 2 3 100 100 1000
// 2 2
// 0 1

// Sample Output
// 0
// 87616
// 12
// 0
// 0
// 1

#include <algorithm>
#include <deque>
#include <iostream>
#include <limits>
#include <vector>
using namespace std;

using ll = long long;

// NOTE: 使用 单调队列 维护滑动窗口的最小值（维护方法见下面的实现）
//
// INFO: 例 1: A = [ _, 114, 514, 810, 1919 ], k = 2
//             D = [ _,   _, 400, 296, 1109 ]
//             | i | D[i] | 队列内容 |        当前窗口         |  min_diff  |     max_diff      |  min_diff * max_diff |
//             | - | ---- | -------- | ----------------------- | ---------- | ----------------- | -------------------- |
//             | 2 |  400 |    [2]   | A[1..2] = [ 114,  514 ] | D[2] = 400 |  514 - 114 = 400  |       160000         |
//             | 3 |  296 |    [3]   | A[2..3] = [ 514,  810 ] | D[3] = 296 |  810 - 514 = 296  |        87616         |
//             | 4 | 1109 |  [3, 4]  | A[3..4] = [ 810, 1919 ] | D[3] = 296 | 1919 - 810 = 1109 |       328264         |
//
// INFO: 例 2：A = [ _, 105, 107, 111, 114, 117, 121 ], k = 3
//             D = [ _,   _,   2,   4,   3,   3,   4 ]
//             | i | D[i] | 队列内容 |           当前窗口          | min_diff |    max_diff   | min_diff * max_diff |
//             | - | ---- | -------- | --------------------------- | -------- | ------------- | ------------------- |
//             | 2 |   2  |    [2]   |               -             |     -    |       -       |          -          |
//             | 3 |   4  |  [2, 3]  | A[1..3] = [ 105, 107, 111 ] | D[2] = 2 | 111 - 105 = 6 |         12          |
//             | 4 |   3  |  [2, 4]  | A[2..4] = [ 107, 111, 114 ] | D[2] = 2 | 114 - 107 = 7 |         14          |
//             | 5 |   3  |    [5]   | A[3..5] = [ 111, 114, 117 ] | D[2] = 2 | 117 - 111 = 6 |         12          |
//             | 6 |   4  |  [5, 6]  | A[4..6] = [ 114, 117, 121 ] | D[2] = 2 | 121 - 114 = 7 |         14          |

void solve() {
  int n, k;
  cin >> n >> k;

  vector<ll> A(n + 1);
  for (int i = 1; i <= n; i++) {
    cin >> A[i];
  }

  sort(A.begin() + 1, A.end());

  // NOTE: 差分数组
  vector<ll> D(n + 1);
  for (int i = 2; i <= n; i++) {
    D[i] = A[i] - A[i - 1];

    // NOTE:  如果有 0，显然最小值为 0，直接输出
    // FIXME: 这里要不上面 i 从 2 开始循环，要不就判 i > 1
    //        否则会导致只要输入有 0 就输出 0
    //        如输入：n = 1, k = 2, A = [ 1, 0 ]
    //        显然结果应该为 1
    if (D[i] == 0) {
      cout << "0\n";
      return;
    }
  }

  ll ans = numeric_limits<ll>::max();

  // NOTE: 单调队列
  deque<int> q;

  for (int i = 2; i <= n; i++) {
    // 弹出队尾比当前值大的，保持递增
    while (q.size() && D[q.back()] >= D[i]) {
      q.pop_back();
    }
    q.push_back(i);

    // 如果 i > k，就每次移走左侧超出窗口边界的元素
    if (i > k && q.front() == i - k) {
      q.pop_front();
    }

    // 从 i = k 开始，每次计算一次答案
    if (i >= k) {
      ll mind = D[q.front()];
      ll maxd = A[i] - A[i - k + 1];
      ans = min(ans, mind * maxd);
    }
  }

  cout << ans << "\n";
}

int main() {
#ifdef LOCAL_JUDGE
  int T;
  cin >> T;
  while (T--)
#endif
    solve();
  return 0;
}
