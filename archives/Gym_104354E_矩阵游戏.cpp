// INFO: Tags : DP 滚动数组
//        URL : https://vjudge.net/problem/Gym-104354E
//
// Bellalabella 正在玩一个矩阵游戏。游戏中有一个 n × m 的矩阵，仅包含 01? 三种字符。
// n 行从上到下依次用 1, 2, ..., n 编号，m 列从左到右依次用 1, 2, ..., m 编号。
// Bellalabella 可以将矩阵中不超过 x 个 ? 变为 1。
// Bellalabella 开始在矩阵的左上角 (1, 1)，并且只能向下或者向右走，最终在 (n, m) 停止，
// 在移动的过程中每经过一个 1 得分会增加一分（包括起点和终点），经过其它字符则分数不变。开始分数为 0 分。
// Bellalabella 在修改矩阵后，会以最优的策略从左上角移动到右下角。
// 他想知道在最优的修改策略下，最多能获得多少分。
//
// 输入格式
// **本题包含多组数据。**
// 第一行包含一个整数 T（1 ≤ T ≤ 2.5 × 10^4），表示数据组数。
// 对于每组数据：
// 第一行包含三个整数 n, m, x（1 ≤ n, m ≤ 500, 0 ≤ x ≤ 10^3）。
// 接下来 n 行，每行包含一个长度为 m 的字符串，保证只包含 01? 三种字符。
// 保证所有数据的 Σ(n*m) ≤ 2.5 × 10^5。
//
// 输出格式
// 对于每组数据：
// 输出一行包含一个整数，表示替换不超过 x 个 ? 的前提下，最多能获得多少分。
//
// HACK: 官方题解
// 考虑 f_(i,j,k) 表示从 (1, 1) 开始走到 (i, j) 恰好替换了 k 个 ? 最多获得的分数，容易得到转移方程：
//             ⎧ max(f_(i,j−1,k), f_(i−1,j,k))                                    s_(i,j) = 0
// f_(i,j,k) = ⎨ max(f_(i,j−1,k), f_(i−1,j,k)) + 1                                s_(i,j) = 1
//             ⎪ max(f_(i,j−1,k), f_(i−1,j,k), f_(i−1,j,k−1)+1, f_(i,j−1,k−1)+1)  k ≠ 0 ∧ s_(i,j) = ?
//             ⎩ max(f_(i,j−1,k), f_(i−1,j,k))                                    k = 0 ∧ s_(i,j) = ?
// 其中 s_(i,j) 表示 (i, j) 的字符，转移复杂度为 O(nmx)。
// 但是空间复杂度也为 O(nmx)，考虑到转移过程中只有不超过 O(m) 个状态有意义，
// 因此我们可以只保存每列最后更新的状态即可，转移方程只需要忽略第一维即可，
// 空间复杂度降到 O(mx)。
//
// INFO: Memory : ~1000 kB
//         Time : ~1800 ms

// Sample Input
// 6
// 3 3 1
// 000
// 001
// ?00
// 3 3 2
// 000
// 001
// ??0
// 3 3 9
// ???
// ???
// ???
// 5 5 25
// ?????
// ?????
// ?????
// ?????
// ?????
// 6 6 3
// 1??000
// 10?000
// 111000
// 000?00
// 0000?0
// 00000?
// 30 30 900
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????
// ??????????????????????????????

// Sample Output
// 1
// 2
// 5
// 9
// 8
// 59

#include <iostream>
#include <vector>
using namespace std;

void solve() {
  int n, m, x;
  cin >> n >> m >> x;

  // NOTE: 下面的 DP 本来是三维的，但每次转移只会用到当前行与前一行，于是使用滚动数组优化
  //       这里 f 为当前行，g 为前一行
  //       原来的三维 DP:
  //         f[i][j][k] = max(f[i - 1][j][k], f[i][j - 1][k])
  //       就可以转化为二维 DP:
  //         f[j][k] = max(g[j][k], f[j - 1][k])
  vector<vector<int>> f(m + 1, vector<int>(x + 1, 0));
  auto g = f;

  // NOTE: 输入和 DP 一起写，少一次循环
  string s;
  for (int i = 1; i <= n; i++) {
    cin >> s;
    for (int j = 1; j <= m; j++) {
      for (int k = 0; k <= x; k++) {
        switch (s[j - 1]) {
          case '0': {
            f[j][k] = max(f[j - 1][k], g[j][k]);
            break;
          }
          case '1': {
            f[j][k] = max(f[j - 1][k], g[j][k]) + 1;
            break;
          }
          case '?': {
            if (k > 0) // ISSUE: 这里没按题解上写，还是过了，感觉像是样例水了
              f[j][k] = max(f[j - 1][k - 1], g[j][k - 1]) + 1;
            else
              f[j][k] = max(f[j - 1][k], g[j][k]);
            break;
          }
        }
      }
    }

    g = f;
  }

  cout << f[m][x] << "\n";
}

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  int T;
  cin >> T;
  while (T--)
    solve();
  return 0;
}
